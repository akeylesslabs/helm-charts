 {{/*
Copyright Akeyless, Inc. All Rights Reserved.
SPDX-License-Identifier: APACHE-2.0
*/}}

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "cache-ha.fullname" . }}-scripts
  namespace: {{ include "cache-ha.namespace" . }}
  labels: {{- include "cache-ha.labels" . | nindent 4 }}
  {{- if .Values.commonAnnotations }}
  annotations: {{- include "common.tplvalues.render" ( dict "value" .Values.commonAnnotations "context" $ ) | nindent 4 }}
  {{- end }}
data:
  start-cache.sh: |
    #!/bin/sh
    set -e
    set -u

    # Cache configuration
    CACHE_PORT="{{ .Values.cache.ports.cache }}"
    CACHE_BIND="0.0.0.0"
    CACHE_APPENDONLY="yes"
    CACHE_PROTECTED_MODE="no"

    # Get pod information
    POD_NAME="${POD_NAME:-$(hostname)}"
    POD_NAMESPACE="${POD_NAMESPACE:-default}"

    # Create cache configuration directory
    mkdir -p {{ .Values.paths.configDir }}
    
    # Create cache configuration
    cat > {{ .Values.paths.configDir }}/{{ .Values.paths.configFile }} << EOF
    # User-supplied common configuration
    bind ${CACHE_BIND}
    appendonly ${CACHE_APPENDONLY}
    protected-mode ${CACHE_PROTECTED_MODE}
    # Configure replica announcement to use hostname only
    replica-announce-ip ${POD_NAME}.{{ include "cache-ha.fullname" . }}-headless.${POD_NAMESPACE}.svc.cluster.local
    replica-announce-port {{ .Values.cache.ports.cache }}
    {{- if .Values.auth.enabled }}
    requirepass \${REDIS_PASSWORD}
    {{- end }}
    {{- if .Values.cache.extraFlags }}
    {{- range .Values.cache.extraFlags }}
    {{ . }}
    {{- end }}
    {{- end }}
    # End of common configuration
    EOF

    # Start cache with TLS if enabled (following Bitnami approach)
    echo "Starting cache server on port ${CACHE_PORT}"
    {{- if .Values.tls.enabled }}
    # Start Redis with TLS-only mode using command line args (Bitnami approach)
    redis-server --port 0 --tls-port {{ .Values.cache.ports.cache }} --tls-cert-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCertFile }} --tls-key-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsKeyFile }} --tls-ca-cert-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCaCertFile }} --tls-replication yes{{- if .Values.tls.authClients }} --tls-auth-clients yes{{- end }} --include {{ .Values.paths.configDir }}/{{ .Values.paths.configFile }} &
    {{- else }}
    # Start Redis in plain mode
    redis-server --port {{ .Values.cache.ports.cache }} --include {{ .Values.paths.configDir }}/{{ .Values.paths.configFile }} &
    {{- end }}

    # Wait for cache to start
    sleep 5
    
    # Let Sentinel handle master election - don't configure replication here
    # Sentinel will automatically configure master-replica relationships
    echo "Cache started - Sentinel will configure replication automatically"
    
    # Wait for cache to finish
    wait

  start-sentinel.sh: |
    #!/bin/sh
    set -e
    set -u

    # Sentinel configuration
    SENTINEL_PORT="{{ .Values.cache.ports.sentinel }}"
    SENTINEL_BIND="0.0.0.0"
    MASTER_SET="{{ .Values.sentinel.masterSet }}"
    QUORUM="{{ .Values.sentinel.quorum }}"
    DOWN_AFTER_MS="{{ .Values.sentinel.downAfterMilliseconds }}"
    FAILOVER_TIMEOUT="{{ .Values.sentinel.failoverTimeout }}"
    PARALLEL_SYNCS="{{ .Values.sentinel.parallelSyncs }}"

    # Get pod information
    POD_NAME="${POD_NAME:-$(hostname)}"
    POD_NAMESPACE="${POD_NAMESPACE:-default}"
    
    # Cache Sentinel approach: Monitor all cache instances and let Sentinel elect master
    # Start by monitoring the first pod as potential master
    MASTER_HOST="{{ include "cache-ha.fullname" . }}-0.{{ include "cache-ha.fullname" . }}-headless.${POD_NAMESPACE}.svc.cluster.local"

    # Create Sentinel configuration directory
    mkdir -p {{ .Values.paths.configDir }}
    
    # Create Sentinel configuration
    cat > {{ .Values.paths.configDir }}/{{ .Values.paths.sentinelConfigFile }} << EOF
    port ${SENTINEL_PORT}
    bind ${SENTINEL_BIND}
    sentinel announce-hostnames yes
    sentinel resolve-hostnames yes
    sentinel announce-port ${SENTINEL_PORT}
    sentinel announce-ip ${POD_NAME}.{{ include "cache-ha.fullname" . }}-headless.${POD_NAMESPACE}.svc.cluster.local
    sentinel monitor ${MASTER_SET} ${MASTER_HOST} {{ .Values.cache.ports.cache }} ${QUORUM}
    sentinel down-after-milliseconds ${MASTER_SET} ${DOWN_AFTER_MS}
    sentinel failover-timeout ${MASTER_SET} ${FAILOVER_TIMEOUT}
    sentinel parallel-syncs ${MASTER_SET} ${PARALLEL_SYNCS}
    {{- if .Values.auth.enabled }}
    sentinel auth-pass ${MASTER_SET} \${REDIS_PASSWORD}
    {{- end }}
    EOF

    # Add known replicas for failover (dynamic based on replica count)
    REPLICA_COUNT="{{ .Values.cache.replicaCount }}"
    for i in $(seq 1 $((REPLICA_COUNT - 1))); do
        echo "sentinel known-replica ${MASTER_SET} {{ include "cache-ha.fullname" . }}-${i}.{{ include "cache-ha.fullname" . }}-headless.${POD_NAMESPACE}.svc.cluster.local {{ .Values.cache.ports.cache }}" >> {{ .Values.paths.configDir }}/{{ .Values.paths.sentinelConfigFile }}
    done

    # Start Sentinel
    echo "Starting Cache Sentinel on port ${SENTINEL_PORT}"
    {{- if .Values.tls.enabled }}
    # Build TLS arguments for sh (POSIX compliant)
    TLS_ARGS="--port 0 --tls-port {{ .Values.cache.ports.sentinel }} --tls-cert-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCertFile }} --tls-key-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsKeyFile }} --tls-ca-cert-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCaCertFile }} --tls-replication yes"
    {{- if .Values.tls.authClients }}
    TLS_ARGS="${TLS_ARGS} --tls-auth-clients yes"
    {{- end }}
    exec redis-server {{ .Values.paths.configDir }}/{{ .Values.paths.sentinelConfigFile }} ${TLS_ARGS} --sentinel
    {{- else }}
    exec redis-sentinel {{ .Values.paths.configDir }}/{{ .Values.paths.sentinelConfigFile }}
    {{- end }}

  prestop-cache.sh: |
    #!/bin/sh
    set -e
    set -u

    # Graceful shutdown
    echo "Stopping cache server gracefully"
    redis-cli -p {{ .Values.cache.ports.cache }} SHUTDOWN SAVE

  prestop-sentinel.sh: |
    #!/bin/sh
    set -e
    set -u

    # Graceful shutdown
    echo "Stopping Cache Sentinel gracefully"
    redis-cli -p {{ .Values.cache.ports.sentinel }} SHUTDOWN
