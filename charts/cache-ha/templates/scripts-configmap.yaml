 {{/*
Copyright Akeyless, Inc. All Rights Reserved.
SPDX-License-Identifier: APACHE-2.0
*/}}

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "cache-ha.fullname" . }}-scripts
  namespace: {{ include "cache-ha.namespace" . }}
  labels: {{- include "cache-ha.labels" . | nindent 4 }}
  {{- if .Values.commonAnnotations }}
  annotations: {{- include "common.tplvalues.render" ( dict "value" .Values.commonAnnotations "context" $ ) | nindent 4 }}
  {{- end }}
data:
  start-cache.sh: |
    #!/bin/sh
    set -e
    set -u

    # Cache configuration
    CACHE_PORT="{{ .Values.cache.ports.cache }}"
    CACHE_BIND="0.0.0.0"
    CACHE_APPENDONLY="yes"
    CACHE_PROTECTED_MODE="no"

    # Get pod information
    POD_NAME="${POD_NAME:-$(hostname)}"
    POD_NAMESPACE="${POD_NAMESPACE:-default}"

    # Create cache configuration directory
    mkdir -p {{ .Values.paths.configDir }}
    
    # Create cache configuration
    cat > {{ .Values.paths.configDir }}/{{ .Values.paths.configFile }} << EOF
    # User-supplied common configuration
    bind ${CACHE_BIND}
    appendonly ${CACHE_APPENDONLY}
    protected-mode ${CACHE_PROTECTED_MODE}
    # Configure replica announcement to use hostname only
    replica-announce-ip ${POD_NAME}.{{ include "cache-ha.fullname" . }}-cache-headless.${POD_NAMESPACE}.svc.cluster.local
    replica-announce-port {{ .Values.cache.ports.cache }}
    {{- if .Values.auth.enabled }}
    requirepass \${REDIS_PASSWORD}
    {{- end }}
    {{- if .Values.tls.enabled }}
    # TLS configuration
    port 0
    tls-port {{ .Values.cache.ports.cache }}
    tls-cert-file \${REDIS_TLS_CERT_FILE}
    tls-key-file \${REDIS_TLS_KEY_FILE}
    tls-ca-cert-file \${REDIS_TLS_CA_FILE}
    tls-replication yes
    {{- if .Values.tls.authClients }}
    tls-auth-clients yes
    {{- end }}
    {{- else }}
    port {{ .Values.cache.ports.cache }}
    {{- end }}
    {{- if .Values.cache.extraFlags }}
    {{- range .Values.cache.extraFlags }}
    {{ . }}
    {{- end }}
    {{- end }}
    # End of common configuration
    EOF

    # Start cache server using config file
    echo "Starting cache server on port ${CACHE_PORT}"
    redis-server {{ .Values.paths.configDir }}/{{ .Values.paths.configFile }} &

    # Wait for cache to start
    sleep 5
    
    # Let Sentinel handle master election - don't configure replication here
    # Sentinel will automatically configure master-replica relationships
    echo "Cache started - Sentinel will configure replication automatically"
    
    # Wait for cache to finish
    wait

  start-sentinel.sh: |
    #!/bin/sh
    set -e
    set -u

    # Sentinel configuration
    SENTINEL_PORT="{{ .Values.cache.ports.sentinel }}"
    SENTINEL_BIND="0.0.0.0"
    MASTER_SET="{{ .Values.sentinel.masterSet }}"
    QUORUM="{{ .Values.sentinel.quorum }}"
    DOWN_AFTER_MS="{{ .Values.sentinel.downAfterMilliseconds }}"
    FAILOVER_TIMEOUT="{{ .Values.sentinel.failoverTimeout }}"
    PARALLEL_SYNCS="{{ .Values.sentinel.parallelSyncs }}"

    # Get pod information
    POD_NAME="${POD_NAME:-$(hostname)}"
    POD_NAMESPACE="${POD_NAMESPACE:-default}"
    
    # Cache Sentinel approach: Monitor all cache instances and let Sentinel elect master
    # Start by monitoring the first cache pod as potential master
    MASTER_HOST="{{ include "cache-ha.fullname" . }}-cache-0.{{ include "cache-ha.fullname" . }}-cache-headless.${POD_NAMESPACE}.svc.cluster.local"

    # Create Sentinel configuration directory
    mkdir -p {{ .Values.paths.configDir }}
    
    # Create Sentinel configuration
    cat > {{ .Values.paths.configDir }}/{{ .Values.paths.sentinelConfigFile }} << EOF
    {{- if .Values.tls.enabled }}
    # TLS configuration
    port 0
    tls-port ${SENTINEL_PORT}
    tls-cert-file \${REDIS_SENTINEL_TLS_CERT_FILE}
    tls-key-file \${REDIS_SENTINEL_TLS_KEY_FILE}
    tls-ca-cert-file \${REDIS_SENTINEL_TLS_CA_FILE}
    tls-replication yes
    {{- if .Values.tls.authClients }}
    tls-auth-clients yes
    {{- end }}
    {{- else }}
    port ${SENTINEL_PORT}
    {{- end }}
    bind ${SENTINEL_BIND}
    sentinel announce-hostnames yes
    sentinel resolve-hostnames yes
    sentinel announce-port ${SENTINEL_PORT}
    sentinel announce-ip ${POD_NAME}.{{ include "cache-ha.fullname" . }}-sentinel-headless.${POD_NAMESPACE}.svc.cluster.local
    sentinel monitor ${MASTER_SET} ${MASTER_HOST} {{ .Values.cache.ports.cache }} ${QUORUM}
    sentinel down-after-milliseconds ${MASTER_SET} ${DOWN_AFTER_MS}
    sentinel failover-timeout ${MASTER_SET} ${FAILOVER_TIMEOUT}
    sentinel parallel-syncs ${MASTER_SET} ${PARALLEL_SYNCS}
    {{- if .Values.auth.enabled }}
    sentinel auth-pass ${MASTER_SET} \${REDIS_PASSWORD}
    {{- end }}
    EOF

    # Add known replicas for failover (dynamic based on replica count)
    REPLICA_COUNT="{{ .Values.cache.replicaCount }}"
    for i in $(seq 1 $((REPLICA_COUNT - 1))); do
        echo "sentinel known-replica ${MASTER_SET} {{ include "cache-ha.fullname" . }}-cache-${i}.{{ include "cache-ha.fullname" . }}-cache-headless.${POD_NAMESPACE}.svc.cluster.local {{ .Values.cache.ports.cache }}" >> {{ .Values.paths.configDir }}/{{ .Values.paths.sentinelConfigFile }}
    done

    # Start Sentinel using config file
    echo "Starting Cache Sentinel on port ${SENTINEL_PORT}"
    exec redis-server {{ .Values.paths.configDir }}/{{ .Values.paths.sentinelConfigFile }} --sentinel

  prestop-cache.sh: |
    #!/bin/sh
    set -e
    set -u

    # Graceful shutdown
    echo "Stopping cache server gracefully"
    {{- if .Values.tls.enabled }}
    redis-cli --tls -p {{ .Values.cache.ports.cache }} SHUTDOWN SAVE
    {{- else }}
    redis-cli -p {{ .Values.cache.ports.cache }} SHUTDOWN SAVE
    {{- end }}

  prestop-sentinel.sh: |
    #!/bin/sh
    set -e
    set -u

    # Graceful shutdown
    echo "Stopping Cache Sentinel gracefully"
    {{- if .Values.tls.enabled }}
    redis-cli --tls -p {{ .Values.cache.ports.sentinel }} SHUTDOWN
    {{- else }}
    redis-cli -p {{ .Values.cache.ports.sentinel }} SHUTDOWN
    {{- end }}
