 {{/*
Copyright Akeyless, Inc. All Rights Reserved.
SPDX-License-Identifier: APACHE-2.0
*/}}

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "cache-ha.fullname" . }}-scripts
  namespace: {{ include "cache-ha.namespace" . }}
  labels: {{- include "cache-ha.labels" . | nindent 4 }}
  {{- if .Values.commonAnnotations }}
  annotations: {{- include "common.tplvalues.render" ( dict "value" .Values.commonAnnotations "context" $ ) | nindent 4 }}
  {{- end }}
data:
  start-cache.sh: |
    #!/bin/sh
    set -e
    set -u

    # Cache configuration
    CACHE_PORT="{{ .Values.cache.ports.cache }}"
    CACHE_BIND="0.0.0.0"
    CACHE_APPENDONLY="yes"
    CACHE_PROTECTED_MODE="no"

    # Get pod information
    POD_NAME="${POD_NAME:-$(hostname)}"
    POD_NAMESPACE="${POD_NAMESPACE:-default}"

    # Create cache configuration directory
    mkdir -p {{ .Values.paths.configDir }}
    
    # Create cache configuration
    cat > {{ .Values.paths.configDir }}/{{ .Values.paths.configFile }} << EOF
    # User-supplied common configuration
    bind ${CACHE_BIND}
    appendonly ${CACHE_APPENDONLY}
    protected-mode ${CACHE_PROTECTED_MODE}
    # Configure replica announcement to use hostname only
    replica-announce-ip ${POD_NAME}.{{ include "cache-ha.fullname" . }}-cache-headless.${POD_NAMESPACE}.svc.cluster.local
    replica-announce-port {{ .Values.cache.ports.cache }}
    {{- if .Values.auth.enabled }}
    requirepass \${REDIS_PASSWORD}
    {{- end }}
    {{- if .Values.cache.extraFlags }}
    {{- range .Values.cache.extraFlags }}
    {{ . }}
    {{- end }}
    {{- end }}
    # End of common configuration
    EOF

    # Wait for DNS to stabilize before starting Redis (blocking with timeout)
    # This prevents hostname resolution errors during startup
    echo "Waiting for DNS to stabilize..."
    timeout=30
    retry_count=0
    while [ $retry_count -lt $timeout ]; do
      all_resolved=true
      for i in $(seq 0 $(({{ .Values.cache.replicaCount }} - 1))); do
        if [ "$i" != "${POD_NAME##*-}" ]; then
          if ! nslookup "{{ include "cache-ha.fullname" . }}-cache-${i}.{{ include "cache-ha.fullname" . }}-cache-headless.${POD_NAMESPACE}.svc.cluster.local" >/dev/null 2>&1; then
            all_resolved=false
            break
          fi
        fi
      done
      if [ "$all_resolved" = "true" ]; then
        echo "DNS ready, starting Redis..."
        break
      fi
      sleep 1
      retry_count=$((retry_count + 1))
    done
    if [ $retry_count -eq $timeout ]; then
      echo "DNS timeout reached, starting Redis anyway..."
    fi

    # Start cache with TLS if enabled
    echo "Starting cache server on port ${CACHE_PORT}"
    {{- if .Values.tls.enabled }}
    # Start Redis with TLS-only mode using command line args (Bitnami approach)
    redis-server --port 0 --tls-port {{ .Values.cache.ports.cache }} --tls-cert-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCertFile }} --tls-key-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsKeyFile }} --tls-ca-cert-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCaCertFile }} --tls-replication yes{{- if .Values.tls.authClients }} --tls-auth-clients yes{{- end }} --include {{ .Values.paths.configDir }}/{{ .Values.paths.configFile }} &
    {{- else }}
    # Start Redis in plain mode
    redis-server --port {{ .Values.cache.ports.cache }} --include {{ .Values.paths.configDir }}/{{ .Values.paths.configFile }} &
    {{- end }}

    # Wait for cache to start
    sleep 10
    
    # Let Sentinel handle master election - don't configure replication here
    # Sentinel will automatically configure master-replica relationships
    echo "Cache started - Sentinel will configure replication automatically"
    
    # Wait for cache to finish
    wait

  start-sentinel.sh: |
    #!/bin/sh
    set -e
    set -u

    # Sentinel configuration
    SENTINEL_PORT="{{ .Values.cache.ports.sentinel }}"
    SENTINEL_BIND="0.0.0.0"
    MASTER_SET="{{ .Values.sentinel.masterSet }}"
    QUORUM="{{ include "cache-ha.sentinelQuorum" . }}"
    DOWN_AFTER_MS="{{ .Values.sentinel.downAfterMilliseconds }}"
    FAILOVER_TIMEOUT="{{ .Values.sentinel.failoverTimeout }}"
    PARALLEL_SYNCS="{{ .Values.sentinel.parallelSyncs }}"

    # Get pod information
    POD_NAME="${POD_NAME:-$(hostname)}"
    POD_NAMESPACE="${POD_NAMESPACE:-default}"
    
    # Cache Sentinel approach: Monitor all cache instances and let Sentinel elect master
    # Start by monitoring the first cache pod as potential master
    MASTER_HOST="{{ include "cache-ha.fullname" . }}-cache-0.{{ include "cache-ha.fullname" . }}-cache-headless.${POD_NAMESPACE}.svc.cluster.local"

    # Create Sentinel configuration directory
    mkdir -p {{ .Values.paths.configDir }}
    
    # Create Sentinel configuration
    cat > {{ .Values.paths.configDir }}/{{ .Values.paths.sentinelConfigFile }} << EOF
    port ${SENTINEL_PORT}
    bind ${SENTINEL_BIND}
    sentinel announce-hostnames yes
    sentinel resolve-hostnames yes
    sentinel announce-port ${SENTINEL_PORT}
    sentinel announce-ip ${POD_NAME}.{{ include "cache-ha.fullname" . }}-sentinel-headless.${POD_NAMESPACE}.svc.cluster.local
    sentinel monitor ${MASTER_SET} ${MASTER_HOST} {{ .Values.cache.ports.cache }} ${QUORUM}
    sentinel down-after-milliseconds ${MASTER_SET} ${DOWN_AFTER_MS}
    sentinel failover-timeout ${MASTER_SET} ${FAILOVER_TIMEOUT}
    sentinel parallel-syncs ${MASTER_SET} ${PARALLEL_SYNCS}
    {{- if .Values.auth.enabled }}
    sentinel auth-pass ${MASTER_SET} \${REDIS_PASSWORD}
    {{- end }}
    # Set log level (suppress SSL errors when set to warning)
    loglevel {{ .Values.logLevel }}
    EOF

    # Add known replicas for failover (dynamic based on replica count)
    REPLICA_COUNT="{{ .Values.cache.replicaCount }}"
    for i in $(seq 1 $((REPLICA_COUNT - 1))); do
        echo "sentinel known-replica ${MASTER_SET} {{ include "cache-ha.fullname" . }}-cache-${i}.{{ include "cache-ha.fullname" . }}-cache-headless.${POD_NAMESPACE}.svc.cluster.local {{ .Values.cache.ports.cache }}" >> {{ .Values.paths.configDir }}/{{ .Values.paths.sentinelConfigFile }}
    done


    # Wait for cache DNS to stabilize before starting Sentinel (blocking with timeout)
    # Only wait for cache pods, not sentinel pods (to avoid circular dependency)
    echo "Waiting for cache DNS to stabilize..."
    timeout=60
    retry_count=0
    while [ $retry_count -lt $timeout ]; do
      all_resolved=true
      # Only check cache pods (sentinels will discover each other dynamically)
      for i in $(seq 0 $(({{ .Values.cache.replicaCount }} - 1))); do
        if ! nslookup "{{ include "cache-ha.fullname" . }}-cache-${i}.{{ include "cache-ha.fullname" . }}-cache-headless.${POD_NAMESPACE}.svc.cluster.local" >/dev/null 2>&1; then
          all_resolved=false
          break
        fi
      done
      if [ "$all_resolved" = "true" ]; then
        echo "Cache DNS ready, starting Sentinel..."
        break
      fi
      sleep 3
      retry_count=$((retry_count + 1))
    done
    if [ $retry_count -eq $timeout ]; then
      echo "Cache DNS timeout reached, starting Sentinel anyway..."
    fi

    # Start Sentinel
    echo "Starting Cache Sentinel on port ${SENTINEL_PORT}"
    {{- if .Values.tls.enabled }}
    # Build TLS arguments for sh (POSIX compliant)
    set -- --port 0 --tls-port {{ .Values.cache.ports.sentinel }} --tls-cert-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCertFile }} --tls-key-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsKeyFile }} --tls-ca-cert-file {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCaCertFile }} --tls-replication yes
    {{- if .Values.tls.authClients }}
    set -- "$@" --tls-auth-clients yes
    {{- end }}
    exec redis-server {{ .Values.paths.configDir }}/{{ .Values.paths.sentinelConfigFile }} "$@" --sentinel
    {{- else }}
    exec redis-server {{ .Values.paths.configDir }}/{{ .Values.paths.sentinelConfigFile }} --sentinel
    {{- end }}

  prestop-cache.sh: |
    #!/bin/sh
    set -e
    set -u

    # Graceful shutdown
    echo "Stopping cache server gracefully"
    {{- if .Values.tls.enabled }}
    redis-cli --tls --cert {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCertFile }} --key {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsKeyFile }} --cacert {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCaCertFile }} -p {{ .Values.cache.ports.cache }} SHUTDOWN SAVE
    {{- else }}
    redis-cli -p {{ .Values.cache.ports.cache }} SHUTDOWN SAVE
    {{- end }}

  prestop-sentinel.sh: |
    #!/bin/sh
    set -e
    set -u

    # Graceful shutdown
    echo "Stopping Cache Sentinel gracefully"
    {{- if .Values.tls.enabled }}
    redis-cli --tls --cert {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCertFile }} --key {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsKeyFile }} --cacert {{ .Values.paths.tlsDir }}/{{ .Values.paths.tlsCaCertFile }} -p {{ .Values.cache.ports.sentinel }} SHUTDOWN
    {{- else }}
    redis-cli -p {{ .Values.cache.ports.sentinel }} SHUTDOWN
    {{- end }}
